(function () { var supports = (function () { var supports = {}; var html, expected; var work = document.createElement('div'); html = "<P><I></P></I>"; work.innerHTML = html; supports.tagSoup = work.innerHTML !== html; work.innerHTML = "<P><i><P></P></i></P>"; supports.selfClose = work.childNodes.length === 2; return supports; })(); var startTag = /^<([\-A-Za-z0-9_]+)((?:\s+[\w-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)>/; var endTag = /^<\/([\-A-Za-z0-9_]+)[^>]*>/; var attr = /([\-A-Za-z0-9_]+)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|([^>\s]+)))?/g; var fillAttr = /^(checked|compact|declare|defer|disabled|ismap|multiple|nohref|noresize|noshade|nowrap|readonly|selected)$/i; var DEBUG = false; function htmlParser(stream, options) { stream = stream || ''; options = options || {}; for (var key in supports) { if (supports.hasOwnProperty(key)) { if (options.autoFix) { options['fix_' + key] = true; } options.fix = options.fix || options['fix_' + key]; } } var stack = []; var append = function (str) { stream += str; }; var prepend = function (str) { stream = str + stream; }; var detect = { comment: /^<!--/, endTag: /^<\//, atomicTag: /^<\s*(script|style|noscript)[\s>]/i, startTag: /^</, chars: /^[^<]/ }; var reader = { comment: function () { var index = stream.indexOf("-->"); if (index >= 0) { return { content: stream.substr(4, index), length: index + 3 }; } }, endTag: function () { var match = stream.match(endTag); if (match) { return { tagName: match[1], length: match[0].length }; } }, atomicTag: function () { var start = reader.startTag(); if (start) { var rest = stream.slice(start.length); var match = rest.match(new RegExp("([\\s\\S]*?)<\/" + start.tagName + "[^>]*>", "i")); if (match) { return { tagName: start.tagName, attrs: start.attrs, escapedAttrs: start.escapedAttrs, content: match[1], length: match[0].length + start.length} } } }, startTag: function () { var match = stream.match(startTag); if (match) { var attrs = {}; var escapedAttrs = {}; match[2].replace(attr, function (match, name) { var value = arguments[2] || arguments[3] || arguments[4] || fillAttr.test(name) && name || null; attrs[name] = value; escapedAttrs[name] = value && value.replace(/(^|[^\\])"/g, '$1\\\"'); }); return { tagName: match[1], attrs: attrs, escapedAttrs: escapedAttrs, unary: match[3], length: match[0].length} } }, chars: function () { var index = stream.indexOf("<"); return { length: index >= 0 ? index : stream.length }; } }; var readToken = function () { for (var type in detect) { if (detect[type].test(stream)) { DEBUG && console.log('suspected ' + type); var token = reader[type](); if (token) { DEBUG && console.log('parsed ' + type, token); token.type = token.type || type; token.text = stream.substr(0, token.length); stream = stream.slice(token.length); return token; } return null; } } }; var readTokens = function (handlers) { var tok; while (tok = readToken()) { if (handlers[tok.type] && handlers[tok.type](tok) === false) { return; } } }; var clear = function () { var rest = stream; stream = ''; return rest; }; var rest = function () { return stream; }; if (options.fix) { (function () { var EMPTY = /^(AREA|BASE|BASEFONT|BR|COL|FRAME|HR|IMG|INPUT|ISINDEX|LINK|META|PARAM|EMBED)$/i; var BLOCK = /^(ADDRESS|APPLET|BLOCKQUOTE|BUTTON|CENTER|DD|DEL|DIR|DIV|DL|DT|FIELDSET|FORM|FRAMESET|HR|IFRAME|INS|ISINDEX|LI|MAP|MENU|NOFRAMES|NOSCRIPT|OBJECT|OL|P|PRE|SCRIPT|TABLE|TBODY|TD|TFOOT|TH|THEAD|TR|UL)$/i; var INLINE = /^(A|ABBR|ACRONYM|APPLET|B|BASEFONT|BDO|BIG|BR|BUTTON|CITE|CODE|DEL|DFN|EM|FONT|I|IFRAME|IMG|INPUT|INS|KBD|LABEL|MAP|OBJECT|Q|S|SAMP|SCRIPT|SELECT|SMALL|SPAN|STRIKE|STRONG|SUB|SUP|TEXTAREA|TT|U|VAR)$/i; var CLOSESELF = /^(COLGROUP|DD|DT|LI|OPTIONS|P|TD|TFOOT|TH|THEAD|TR)$/i; var stack = []; stack.last = function () { return this[this.length - 1]; }; stack.lastTagNameEq = function (tagName) { var last = this.last(); return last && last.tagName && last.tagName.toUpperCase() === tagName.toUpperCase(); }; stack.containsTagName = function (tagName) { for (var i = 0, tok; tok = this[i]; i++) { if (tok.tagName === tagName) { return true; } } return false; }; var correct = function (tok) { if (tok && tok.type === 'startTag') { tok.unary = EMPTY.test(tok.tagName) || tok.unary; } return tok; }; var readTokenImpl = readToken; var peekToken = function () { var tmp = stream; var tok = correct(readTokenImpl()); stream = tmp; return tok; }; var closeLast = function () { var tok = stack.pop(); prepend('</' + tok.tagName + '>'); }; var handlers = { startTag: function (tok) { var tagName = tok.tagName; if (tagName.toUpperCase() === 'TR' && stack.lastTagNameEq('TABLE')) { prepend('<TBODY>'); prepareNextToken(); } else if (options.fix_selfClose && CLOSESELF.test(tagName) && stack.containsTagName(tagName)) { if (stack.lastTagNameEq(tagName)) { closeLast(); } else { prepend('</' + tok.tagName + '>'); prepareNextToken(); } } else if (!tok.unary) { stack.push(tok); } }, endTag: function (tok) { var last = stack.last(); if (last) { if (options.fix_tagSoup && !stack.lastTagNameEq(tok.tagName)) { closeLast(); } else { stack.pop(); } } else if (options.fix_tagSoup) { skipToken(); } } }; var skipToken = function () { readTokenImpl(); prepareNextToken(); }; var prepareNextToken = function () { var tok = peekToken(); if (tok && handlers[tok.type]) { handlers[tok.type](tok); } }; readToken = function () { prepareNextToken(); return correct(readTokenImpl()); }; })(); } return { append: append, readToken: readToken, readTokens: readTokens, clear: clear, rest: rest, stack: stack }; }; htmlParser.supports = supports; htmlParser.tokenToString = function (tok) { var handler = { comment: function (tok) { return '<--' + tok.content + '-->'; }, endTag: function (tok) { return '</' + tok.tagName + '>'; }, atomicTag: function (tok) { console.log(tok); return handler.startTag(tok) + tok.content + handler.endTag(tok); }, startTag: function (tok) { var str = '<' + tok.tagName; for (var key in tok.attrs) { var val = tok.attrs[key]; str += ' ' + key + '="' + (val ? val.replace(/(^|[^\\])"/g, '$1\\\"') : '') + '"'; } return str + (tok.unary ? '/>' : '>'); }, chars: function (tok) { return tok.text; } }; return handler[tok.type](tok); }; for (var key in supports) { htmlParser.browserHasFlaw = htmlParser.browserHasFlaw || (!supports[key]) && key; } this.htmlParser = htmlParser; })();
(function () { function i() { } function s(e) { return "function" == typeof e } function o(e, t, n) { var r, i = e && e.length || 0; for (r = 0; r < i; r++) { t.call(n, e[r], r) } } function u(e, t, n) { var r; for (r in e) { if (e.hasOwnProperty(r)) { t.call(n, r, e[r]) } } } function a(e, t) { u(t, function (t, n) { e[t] = n }); return e } function f(e, t) { e = e || {}; u(t, function (t, n) { if (e[t] == null) { e[t] = n } }); return e } function l(e) { try { return r.call(e) } catch (t) { var n = []; o(e, function (e) { n.push(e) }); return n } } function c(e) { return /^script$/i.test(e.tagName) } var e = this; if (e.postscribe) { return } var t = true; var n = false; var r = Array.prototype.slice; var h = function () { function t(t, n, r) { var i = e + n; if (arguments.length === 2) { var s = t.getAttribute(i); return s == null ? s : String(s) } else if (r != null && r !== "") { t.setAttribute(i, r) } else { t.removeAttribute(i) } } function r(e) { this.actuals = [e]; this.proxyHistory = ""; this.proxyRoot = e.ownerDocument.createElement(e.nodeName); t(this.proxyRoot, "proxyof", 0) } var e = "data-ps-"; r.prototype.buildChunk = function (t) { var n = this.actuals.length, r = [], i = [], s = []; o(t, function (t) { r.push(t.text); if (t.attrs) { if (!/^noscript$/i.test(t.tagName)) { var o = n++; i.push(t.text.replace(/(\/?>)/, " " + e + "id=" + o + " $1")); s.push(t.type === "atomicTag" ? "" : "<" + t.tagName + " " + e + "proxyof=" + o + (t.unary ? "/>" : ">")) } } else { i.push(t.text); s.push(t.type === "endTag" ? t.text : "") } }); return { tokens: t, raw: r.join(""), actual: i.join(""), proxy: s.join("")} }; r.prototype.write = function (e) { var t = this.buildChunk(e); if (!t.actual) { return } t.html = this.proxyHistory + t.actual; this.proxyHistory += t.proxy; this.proxyRoot.innerHTML = t.html; if (n) { t.proxyInnerHTML = this.proxyRoot.innerHTML } this.walkNodes(); if (n) { t.actualInnerHTML = this.actuals[0].innerHTML } return t }; r.prototype.walkNodes = function () { var e, n = [this.proxyRoot]; while ((e = n.shift()) != null) { var r = e.nodeType === 1; var i = r && t(e, "proxyof"); if (!i) { if (r) { this.actuals[t(e, "id")] = e; t(e, "id", null) } var s = e.parentNode && t(e.parentNode, "proxyof"); if (s) { this.actuals[s].appendChild(e) } } n.unshift.apply(n, l(e.childNodes)) } }; return r } (); var p = function () { function t(t, n) { var r = t.ownerDocument; a(this, { root: t, options: f(n, { error: i }), stream: new h(t), parser: e.htmlParser("", { autoFix: true }), doc: r, win: r.defaultView || r.parentWindow }) } t.prototype.exec = function (e, t) { e.run.call(this.win, this.doc); delete e.run; t() }; var r = e.execScript ? "execScript" : "eval"; t.prototype.script_inline = function (e, t) { try { this.win[r](e.expr) } catch (n) { this.options.error(n) } t() }; t.prototype.script_remote = function (e, t) { var n = this; var r = this.doc.createElement("script"); var i = { src: e.src, async: true, onload: function () { r = r.onload = r.onreadystatechange = r.onerror = null; t() }, onreadystatechange: function () { if (/^(loaded|complete)$/.test(r.readyState)) { r.onload() } }, onerror: function () { n.options.error({ message: "remote script failed " + e.src }); r.onload() } }; u(e.tok.attrs, function (e, t) { if (!i.hasOwnProperty(e)) { r.setAttribute(e, t) } }); a(r, i); this.root.appendChild(r) }; t.prototype.write = function (e, t, r) { this.parser.append(e.html); var i, s = []; while ((i = this.parser.readToken()) != null && !c(i)) { s.push(i) } var o = this.stream.write(s); if (n) { e.chunk = o } if (i) { this.onScriptToken(i, r) } t() }; t.prototype.onScriptToken = function (e, t) { var n = this.parser.clear(); var r = e.attrs.src || e.attrs.SRC; t.subtask(r ? { type: "script_remote", src: r, tok: e} : { type: "script_inline", inlinable: true, tok: e, expr: e.content.replace(/<!\[CDATA\[([\s\S]*?)\]\]>/g, "$1").replace(/<!--([\s\S]*?)-->/g, "$1") }); if (n) { t.subtask({ type: "write", html: n, inlinable: true }) } }; return t } (); var d = function () { function e(e, t) { var n = []; a(this, { worker: e, options: f(t, { taskAdd: i, taskStart: i, taskDone: i }), active: null, deferred: n, _deferred: n }) } e.prototype.task = function (e, t) { this.options.taskAdd(e); this.deferred.push(e); if (t) { this.deferred.push(t) } this.nextIfIdle(); return this }; e.prototype.subtask = function (e) { this.options.taskAdd(e); if (e.inlinable && !this._deferred.length) { this.startTask(e) } else { this._deferred.push(e) } }; e.prototype.startTask = function (e) { var t = this; if (this.stopRequested) { return this._deferred.unshift(e) } if (s(e)) { e.call(this); return this.nextIfIdle() } var n = { active: this.active, _deferred: this._deferred }; a(this, { active: e, _deferred: [] }); this.options.taskStart(e); this.worker[e.type](e, function () { t.doneTask(n) }, this) }; e.prototype.doneTask = function (e) { this.options.taskDone(this.active); [].unshift.apply(e._deferred, this._deferred); a(this, e); if (this.onStop && !this.active) { this.onStop(); delete this.onStop } this.nextIfIdle() }; e.prototype.nextIfIdle = function () { var e = !this.active && this.deferred.shift(); if (e) { this.startTask(e) } }; e.prototype.stop = function (e) { e = e || i; this.stopRequested = true; if (!this.active) { e() } else { this.onStop = e } }; e.prototype.start = function () { this.stopRequested = false; delete this.onStop; this.nextIfIdle(); return this }; return e } (); var v = function () { function e() { a(this, { tasks: [], roots: [], active: null }) } e.prototype.taskAdd = function (e) { e.id = this.tasks.length; this.tasks.push(e); e.state = "waiting"; if (this.active) { e.cause = this.active.id; (this.active.effects = this.active.effects || []).push(e.id) } return e }; e.prototype.taskStart = function (e) { var t = this.active; if (t) { e.parent = t.id; (t.childIds = t.childIds || []).push(e.id); (t.children = t.children || []).push(e) } else { this.roots.push(e) } e.state = "started"; this.active = e }; e.prototype.taskDone = function (e) { e.state = "done"; this.active = e.parent != null ? this.tasks[e.parent] : null }; return e } (); var m = function () { function n(e, n, r, s) { function m(e) { l.subtask({ type: "write", html: e, inlinable: true }); r.afterWrite(e) } r = f(r, { afterWrite: i, done: i }); var u = new p(e, r); var l = new d(u, t && new v); l.name = r.name; o.writers[l.name] = l; var c = e.ownerDocument; var h = { write: c.write, writeln: c.writeln }; a(c, { write: m, writeln: function (e) { m(e + "\n") } }); l.task(n, function () { a(c, h); r.done(); s() }); return l } function o(t, n, o) { t = /^#/.test(t) ? e.document.getElementById(t.substr(1)) : t.jquery ? t[0] : t; o = o || {}; var u = s(n) ? { type: "exec", run: n} : { type: "write", html: n }; var f = a([t, u, o], { type: "rootTask" }); r.task(f); return t.postscribe = { stop: function () { if (f.flow) { f.flow.stop() } else { f[1] = { type: "exec", run: i} } } } } var r = new d({ rootTask: function (e, t) { e.push(t); e.flow = n.apply(null, e) } }); return a(o, { writers: {}, queue: r, Worker: p, Flow: d, Tracer: v, WriteStream: h, json: function () { var e = {}; u(this.writers, function (t, n) { e[t] = n.options.roots }); return e } }) } (); e.postscribe = m })()
var inDapIF=true;